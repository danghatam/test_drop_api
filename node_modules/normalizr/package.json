{
  "_args": [
    [
      "normalizr@https://registry.npmjs.org/normalizr/-/normalizr-2.1.0.tgz",
      "/Users/danghatam/Workspace/Project/Drops-web"
    ]
  ],
  "_from": "normalizr@>=2.1.0 <3.0.0",
  "_id": "normalizr@2.1.0",
  "_inCache": true,
  "_location": "/normalizr",
  "_phantomChildren": {},
  "_requested": {
    "name": "normalizr",
    "raw": "normalizr@https://registry.npmjs.org/normalizr/-/normalizr-2.1.0.tgz",
    "rawSpec": "https://registry.npmjs.org/normalizr/-/normalizr-2.1.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/normalizr/-/normalizr-2.1.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/normalizr/-/normalizr-2.1.0.tgz",
  "_shasum": "58a0324d175411c6bd6033d6bb0ac517cc098cac",
  "_shrinkwrap": null,
  "_spec": "normalizr@https://registry.npmjs.org/normalizr/-/normalizr-2.1.0.tgz",
  "_where": "/Users/danghatam/Workspace/Project/Drops-web",
  "author": {
    "name": "Dan Abramov"
  },
  "bugs": {
    "url": "https://github.com/paularmstrong/normalizr/issues"
  },
  "contributors": [
    {
      "name": "Paul Armstrong"
    }
  ],
  "dependencies": {
    "lodash": "^4.11.2"
  },
  "description": "Normalizes JSON according to schema for Redux and Flux applications",
  "devDependencies": {
    "babel-cli": "^6.8.0",
    "babel-core": "^6.8.0",
    "babel-loader": "^6.2.4",
    "babel-preset-es2015": "^6.6.0",
    "babel-preset-stage-1": "^6.5.0",
    "babel-register": "^6.8.0",
    "chai": "^3.2.0",
    "mocha": "^2.4.5",
    "rimraf": "^2.4.2",
    "webpack": "^1.13.0"
  },
  "files": [
    "dist",
    "lib",
    "src"
  ],
  "homepage": "https://github.com/paularmstrong/normalizr",
  "keywords": [
    "api",
    "flux",
    "json",
    "normalize"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "normalizr",
  "optionalDependencies": {},
  "readme": "# normalizr [![build status](https://img.shields.io/travis/paularmstrong/normalizr/master.svg?style=flat-square)](https://travis-ci.org/paularmstrong/normalizr) [![npm version](https://img.shields.io/npm/v/normalizr.svg?style=flat-square)](https://www.npmjs.com/package/normalizr) [![npm downloads](https://img.shields.io/npm/dm/normalizr.svg?style=flat-square)](https://www.npmjs.com/package/normalizr)\n\nNormalizes deeply nested JSON API responses according to a schema for [Flux](https://facebook.github.io/flux) and [Redux](http://rackt.github.io/redux) apps.  \nKudos to Jing Chen for suggesting this approach.\n\n## Installation\n\n```\nnpm install --save normalizr\n```\n\n## Sample App\n\n### Flux\n\nSee **[flux-react-router-example](https://github.com/gaearon/flux-react-router-example)**.\n\n### Redux\n\nSee **[redux/examples/real-world](https://github.com/rackt/redux/tree/master/examples/real-world)**.\n\n## The Problem\n\n* You have a JSON API that returns deeply nested objects;  \n* You want to port your app to [Flux](https://github.com/facebook/flux) or [Redux](http://rackt.github.io/redux);\n* You noticed [it's hard](https://groups.google.com/forum/#!topic/reactjs/jbh50-GJxpg) for Stores (or Reducers) to consume data from nested API responses.  \n\nNormalizr takes JSON and a schema and **replaces nested entities with their IDs, gathering all entities in dictionaries**.\n\nFor example,\n\n```javascript\n[{\n  id: 1,\n  title: 'Some Article',\n  author: {\n    id: 1,\n    name: 'Dan'\n  }\n}, {\n  id: 2,\n  title: 'Other Article',\n  author: {\n    id: 1,\n    name: 'Dan'\n  }\n}]\n```\n\ncan be normalized to\n\n```javascript\n{\n  result: [1, 2],\n  entities: {\n    articles: {\n      1: {\n        id: 1,\n        title: 'Some Article',\n        author: 1\n      },\n      2: {\n        id: 2,\n        title: 'Other Article',\n        author: 1\n      }\n    },\n    users: {\n      1: {\n        id: 1,\n        name: 'Dan'\n      }\n    }\n  }\n}\n```\n\nNote the flat structure (all nesting is gone).\n\n## Features\n\n* Entities can be nested inside other entities, objects and arrays;\n* Combine entity schemas to express any kind of API response;\n* Entities with same IDs are automatically merged (with a warning if they differ);\n* Allows using a custom ID attribute (e.g. slug).\n\n## Usage\n\n```javascript\nimport { normalize, Schema, arrayOf } from 'normalizr';\n```\n\nFirst, define a schema for our entities:\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n```\n\nThen we define nesting rules:\n\n```javascript\narticle.define({\n  author: user,\n  contributors: arrayOf(user)\n});\n```\n\nNow we can use this schema in our API response handlers:\n\n```javascript\nconst ServerActionCreators = {\n\n  // These are two different XHR endpoints with different response schemas.\n  // We can use the schema objects defined earlier to express both of them:\n\n  receiveOneArticle(response) {\n\n    // Here, the response is an object containing data about one article.\n    // Passing the article schema as second parameter to normalize() lets it\n    // correctly traverse the response tree and gather all entities:\n\n    // BEFORE:\n    // {\n    //   id: 1,\n    //   title: 'Some Article',\n    //   author: {\n    //     id: 7,\n    //     name: 'Dan'\n    //   },\n    //   contributors: [{\n    //     id: 10,\n    //     name: 'Abe'\n    //   }, {\n    //     id: 15,\n    //     name: 'Fred'\n    //   }]\n    // }\n    //\n    // AFTER:\n    // {\n    //   result: 1,                    // <--- Note object is referenced by ID\n    //   entities: {\n    //     articles: {\n    //       1: {\n    //         author: 7,              // <--- Same happens for references to\n    //         contributors: [10, 15]  // <--- other entities in the schema\n    //         ...}\n    //     },\n    //     users: {\n    //       7: { ... },\n    //       10: { ... },\n    //       15: { ... }\n    //     }\n    //   }\n    // }\n\n    response = normalize(response, article);\n\n    AppDispatcher.handleServerAction({\n      type: ActionTypes.RECEIVE_ONE_ARTICLE,\n      response\n    });\n  },\n\n  receiveAllArticles(response) {\n\n    // Here, the response is an object with the key 'articles' referencing\n    // an array of article objects. Passing { articles: arrayOf(article) } as\n    // second parameter to normalize() lets it correctly traverse the response\n    // tree and gather all entities:\n\n    // BEFORE:\n    // {\n    //   articles: [{\n    //     id: 1,\n    //     title: 'Some Article',\n    //     author: {\n    //       id: 7,\n    //       name: 'Dan'\n    //     },\n    //     ...\n    //   },\n    //   ...\n    //   ]\n    // }\n    //\n    // AFTER:\n    // {\n    //   result: {\n    //    articles: [1, 2, ...]     // <--- Note how object array turned into ID array\n    //   },\n    //   entities: {\n    //     articles: {\n    //       1: { author: 7, ... }, // <--- Same happens for references to other entities in the schema\n    //       2: { ... },\n    //       ...\n    //     },\n    //     users: {\n    //       7: { ... },\n    //       ..\n    //     }\n    //   }\n    // }\n\n    response = normalize(response, {\n      articles: arrayOf(article)\n    });\n\n    AppDispatcher.handleServerAction({\n      type: ActionTypes.RECEIVE_ALL_ARTICLES,\n      response\n    });\n  }\n}\n```\n\nFinally, different Stores can tune in to listen to all API responses and grab entity lists from `action.response.entities`:\n\n```javascript\nAppDispatcher.register((payload) => {\n  const { action } = payload;\n\n  if (action.response && action.response.entities && action.response.entities.users) {\n    mergeUsers(action.response.entities.users);\n    UserStore.emitChange();\n    break;\n  }\n});\n```\n\n## API Reference\n\n### `new Schema(key, [options])`\n\nSchema lets you define a type of entity returned by your API.  \nThis should correspond to model in your server code.  \n\nThe `key` parameter lets you specify the name of the dictionary for this kind of entity.  \n\n```javascript\nconst article = new Schema('articles');\n\n// You can use a custom id attribute\nconst article = new Schema('articles', { idAttribute: 'slug' });\n\n// Or you can specify a function to infer it\nfunction generateSlug(entity) { /* ... */ }\nconst article = new Schema('articles', { idAttribute: generateSlug });\n\n// You can also specify meta properties to be used for customizing the output in assignEntity (see below)\nconst article = new Schema('articles', { idAttribute: 'slug', meta: { removeProps: ['publisher'] }});\n\n// You can specify custom `assignEntity` function to be run after the `assignEntity` function passed to `normalize`\nconst article = new Schema('articles', { assignEntity: function (output, key, value, input) {\n  if (key === 'id_str') {\n    obj.id = value;\n    if ('id_str' in obj) {\n      delete obj.id_str;\n    }\n  } else {\n    obj[key] = value;\n  }\n}})\n```\n\n### `Schema.prototype.define(nestedSchema)`\n\nLets you specify relationships between different entities.  \n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  author: user\n});\n```\n\n### `Schema.prototype.getKey()`\n\nReturns the key of the schema.\n\n```javascript\nconst article = new Schema('articles');\n\narticle.getKey();\n// articles\n```\n\n### `Schema.prototype.getIdAttribute()`\n\nReturns the idAttribute of the schema.\n\n```javascript\nconst article = new Schema('articles');\nconst slugArticle = new Schema('articles', { idAttribute: 'slug' });\n\narticle.getIdAttribute();\n// id\nslugArticle.getIdAttribute();\n// slug\n```\n\n### `arrayOf(schema, [options])`\n\nDescribes an array of the schema passed as argument.\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  author: user,\n  contributors: arrayOf(user)\n});\n```\n\nIf the array contains entities with different schemas, you can use the `schemaAttribute` option to specify which schema to use for each entity:\n\n```javascript\nconst article = new Schema('articles');\nconst image = new Schema('images');\nconst video = new Schema('videos');\nconst asset = {\n  images: image,\n  videos: video\n};\n\n// You can specify the name of the attribute that determines the schema\narticle.define({\n  assets: arrayOf(asset, { schemaAttribute: 'type' })\n});\n\n// Or you can specify a function to infer it\nfunction inferSchema(entity) { /* ... */ }\narticle.define({\n  assets: arrayOf(asset, { schemaAttribute: inferSchema })\n});\n```\n\n### `valuesOf(schema, [options])`\n\nDescribes a map whose values follow the schema passed as argument.\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  collaboratorsByRole: valuesOf(user)\n});\n```\n\nIf the map contains entities with different schemas, you can use the `schemaAttribute` option to specify which schema to use for each entity:\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\nconst group = new Schema('groups');\nconst collaborator = {\n  users: user,\n  groups: group\n};\n\n// You can specify the name of the attribute that determines the schema\narticle.define({\n  collaboratorsByRole: valuesOf(collaborator, { schemaAttribute: 'type' })\n});\n\n// Or you can specify a function to infer it\nfunction inferSchema(entity) { /* ... */ }\narticle.define({\n  collaboratorsByRole: valuesOf(collaborator, { schemaAttribute: inferSchema })\n});\n```\n\n### `unionOf(schemaMap, [options])`\n\nDescribe a schema which is a union of multiple schemas.  This is useful if you need the polymorphic behavior provided by `arrayOf` or `valuesOf` but for non-collection fields.\n\nUse the required `schemaAttribute` option to specify which schema to use for each entity.\n\n```javascript\nconst group = new Schema('groups');\nconst user = new Schema('users');\n\n// a member can be either a user or a group\nconst member = {\n  users: user,\n  groups: group\n};\n\n// You can specify the name of the attribute that determines the schema\ngroup.define({\n  owner: unionOf(member, { schemaAttribute: 'type' })\n});\n\n// Or you can specify a function to infer it\nfunction inferSchema(entity) { /* ... */ }\ngroup.define({\n  creator: unionOf(member, { schemaAttribute: inferSchema })\n});\n```\n\nA `unionOf` schema can also be combined with `arrayOf` and `valueOf` with the same behavior as each supplied with the `schemaAttribute` option.\n\n```javascript\nconst group = new Schema('groups');\nconst user = new Schema('users');\n\nconst member = unionOf({\n  users: user,\n  groups: group\n}, { schemaAttribute: 'type' });\n\ngroup.define({\n  owner: member,\n  members: arrayOf(member),\n  relationships: valuesOf(member)\n});\n```\n\n### `normalize(obj, schema, [options])`\n\nNormalizes object according to schema.  \nPassed `schema` should be a nested object reflecting the structure of API response.\n\nYou may optionally specify any of the following options:\n\n* `assignEntity` (function): This is useful if your backend emits additional fields, such as separate ID fields, you'd like to delete in the normalized entity. See [the tests](https://github.com/gaearon/normalizr/blob/a0931d7c953b24f8f680b537b5f23a20e8483be1/test/index.js#L89-L200) and the [discussion](https://github.com/gaearon/normalizr/issues/10) for a usage example.\n\n* `mergeIntoEntity` (function): You can use this to resolve conflicts when merging entities with the same key. See [the test](https://github.com/gaearon/normalizr/blob/47ed0ecd973da6fa7c8b2de461e35b293ae52047/test/index.js#L132-L197) and the [discussion](https://github.com/gaearon/normalizr/issues/34) for a usage example.\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  author: user,\n  contributors: arrayOf(user),\n  meta: {\n    likes: arrayOf({\n      user: user\n    })\n  }\n});\n\n// ...\n\n// Normalize one article object\nconst json = { id: 1, author: ... };\nconst normalized = normalize(json, article);\n\n// Normalize an array of article objects\nconst arr = [{ id: 1, author: ... }, ...]\nconst normalized = normalize(arr, arrayOf(article));\n\n// Normalize an array of article objects, referenced by an object key:\nconst wrappedArr = { articles: [{ id: 1, author: ... }, ...] }\nconst normalized = normalize(wrappedArr, {\n  articles: arrayOf(article)\n});\n```\n\n## Explanation by Example\n\nSay, you have `/articles` API with the following schema:\n\n```\narticles: article*\n\narticle: {\n  author: user,\n  likers: user*\n  primary_collection: collection?\n  collections: collection*\n}\n\ncollection: {\n  curator: user\n}\n```\n\nWithout normalizr, your Stores would need to know too much about API response schema.  \nFor example, `UserStore` would include a lot of boilerplate to extract fresh user info when articles are fetched:\n\n```javascript\n// Without normalizr, you'd have to do this in every store:\n\nAppDispatcher.register((payload) => {\n  const { action } = payload;\n\n  switch (action.type) {\n  case ActionTypes.RECEIVE_USERS:\n    mergeUsers(action.rawUsers);\n    break;\n\n  case ActionTypes.RECEIVE_ARTICLES:\n    action.rawArticles.forEach(rawArticle => {\n      mergeUsers([rawArticle.user]);\n      mergeUsers(rawArticle.likers);\n\n      mergeUsers([rawArticle.primaryCollection.curator]);\n      rawArticle.collections.forEach(rawCollection => {\n        mergeUsers(rawCollection.curator);\n      });\n    });\n\n    UserStore.emitChange();\n    break;\n  }\n});\n```\n\nNormalizr solves the problem by converting API responses to a flat form where nested entities are replaced with IDs:\n\n```javascript\n{\n  result: [12, 10, 3, ...],\n  entities: {\n    articles: {\n      12: {\n        authorId: 3,\n        likers: [2, 1, 4],\n        primaryCollection: 12,\n        collections: [12, 11]\n      },\n      ...\n    },\n    users: {\n      3: {\n        name: 'Dan'\n      },\n      2: ...,\n      4: ....\n    },\n    collections: {\n      12: {\n        curator: 2,\n        name: 'Stuff'\n      },\n      ...\n    }\n  }\n}\n```\n\nThen `UserStore` code can be rewritten as:\n\n```javascript\n// With normalizr, users are always in action.response.entities.users\n\nAppDispatcher.register((payload) => {\n  const { action } = payload;\n\n  if (action.response && action.response.entities && action.response.entities.users) {\n    mergeUsers(action.response.entities.users);\n    UserStore.emitChange();\n    break;\n  }\n});\n```\n\n## Dependencies\n\n* Some methods from `lodash`, such as `isObject`, `isEqual` and `mapValues`\n\n## Browser Support\n\nModern browsers with ES5 environments are supported.  \nThe minimal supported IE version is IE 9.\n\n## Running Tests\n\n```\ngit clone https://github.com/gaearon/normalizr.git\ncd normalizr\nnpm install\nnpm test # run tests once\nnpm run test:watch # run test watcher\n```\n\n## Credits\n\nNormalizr was originally created by [Dan Abramov](http://github.com/gaearon) and inspired by a conversation with [Jing Chen](https://twitter.com/jingc).  \nIt has since received contributions from different [community members](https://github.com/gaearon/normalizr/graphs/contributors).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/paularmstrong/normalizr.git"
  },
  "scripts": {
    "build": "webpack && babel src --out-dir lib",
    "prebuild": "rimraf dist lib",
    "prepublish": "npm run build",
    "test": "mocha --compilers js:babel-register --recursive",
    "test:watch": "npm run test -- --watch"
  },
  "version": "2.1.0"
}
